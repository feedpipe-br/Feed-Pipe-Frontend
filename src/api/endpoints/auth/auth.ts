/**
 * Generated by orval v8.0.1 üç∫
 * Do not edit manually.
 * Feed Pipe API
 * Your project description
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import type {
  Login,
  PasswordChange,
  PasswordReset,
  PasswordResetConfirm,
  PatchedUserDetails,
  Register,
  ResendEmailVerification,
  RestAuthDetail,
  Token,
  UserDetails,
  VerifyEmail,
} from "../feedPipeAPI.schemas";

import { axiosInstance } from "../../../../axios/axios";

// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> =
  (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2 ? A : B;

type WritableKeys<T> = {
  [P in keyof T]-?: IfEquals<
    { [Q in P]: T[P] },
    { -readonly [Q in P]: T[P] },
    P
  >;
}[keyof T];

type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (
  k: infer I,
) => void
  ? I
  : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>]
  ? {
      [P in keyof Writable<T>]: T[P] extends object
        ? NonReadonly<NonNullable<T[P]>>
        : T[P];
    }
  : DistributeReadOnlyOverUnions<T>;

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Check the credentials and return the REST Token
if the credentials are valid and authenticated.
Calls Django Auth login method to register User ID
in Django session framework

Accept the following POST parameters: username, password
Return the REST Framework Token Object's key.
 */
export type authLoginCreateResponse200 = {
  data: Token;
  status: 200;
};

export type authLoginCreateResponseSuccess = authLoginCreateResponse200 & {
  headers: Headers;
};
export type authLoginCreateResponse = authLoginCreateResponseSuccess;

export const getAuthLoginCreateUrl = () => {
  return `/api/auth/login/`;
};

export const authLoginCreate = async (
  login: Login,
  options?: RequestInit,
): Promise<authLoginCreateResponse> => {
  return axiosInstance<authLoginCreateResponse>(getAuthLoginCreateUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(login),
  });
};

export const getAuthLoginCreateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authLoginCreate>>,
    TError,
    { data: Login },
    TContext
  >;
  request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authLoginCreate>>,
  TError,
  { data: Login },
  TContext
> => {
  const mutationKey = ["authLoginCreate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authLoginCreate>>,
    { data: Login }
  > = (props) => {
    const { data } = props ?? {};

    return authLoginCreate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthLoginCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof authLoginCreate>>
>;
export type AuthLoginCreateMutationBody = Login;
export type AuthLoginCreateMutationError = unknown;

export const useAuthLoginCreate = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authLoginCreate>>,
      TError,
      { data: Login },
      TContext
    >;
    request?: SecondParameter<typeof axiosInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof authLoginCreate>>,
  TError,
  { data: Login },
  TContext
> => {
  return useMutation(getAuthLoginCreateMutationOptions(options), queryClient);
};
/**
 * Calls Django logout method and delete the Token object
assigned to the current User object.

Accepts/Returns nothing.
 */
export type authLogoutCreateResponse200 = {
  data: RestAuthDetail;
  status: 200;
};

export type authLogoutCreateResponseSuccess = authLogoutCreateResponse200 & {
  headers: Headers;
};
export type authLogoutCreateResponse = authLogoutCreateResponseSuccess;

export const getAuthLogoutCreateUrl = () => {
  return `/api/auth/logout/`;
};

export const authLogoutCreate = async (
  options?: RequestInit,
): Promise<authLogoutCreateResponse> => {
  return axiosInstance<authLogoutCreateResponse>(getAuthLogoutCreateUrl(), {
    ...options,
    method: "POST",
  });
};

export const getAuthLogoutCreateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authLogoutCreate>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authLogoutCreate>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["authLogoutCreate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authLogoutCreate>>,
    void
  > = () => {
    return authLogoutCreate(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthLogoutCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof authLogoutCreate>>
>;

export type AuthLogoutCreateMutationError = unknown;

export const useAuthLogoutCreate = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authLogoutCreate>>,
      TError,
      void,
      TContext
    >;
    request?: SecondParameter<typeof axiosInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof authLogoutCreate>>,
  TError,
  void,
  TContext
> => {
  return useMutation(getAuthLogoutCreateMutationOptions(options), queryClient);
};
/**
 * Calls Django Auth SetPasswordForm save method.

Accepts the following POST parameters: new_password1, new_password2
Returns the success/fail message.
 */
export type authPasswordChangeCreateResponse200 = {
  data: RestAuthDetail;
  status: 200;
};

export type authPasswordChangeCreateResponseSuccess =
  authPasswordChangeCreateResponse200 & {
    headers: Headers;
  };
export type authPasswordChangeCreateResponse =
  authPasswordChangeCreateResponseSuccess;

export const getAuthPasswordChangeCreateUrl = () => {
  return `/api/auth/password/change/`;
};

export const authPasswordChangeCreate = async (
  passwordChange: PasswordChange,
  options?: RequestInit,
): Promise<authPasswordChangeCreateResponse> => {
  return axiosInstance<authPasswordChangeCreateResponse>(
    getAuthPasswordChangeCreateUrl(),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(passwordChange),
    },
  );
};

export const getAuthPasswordChangeCreateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authPasswordChangeCreate>>,
    TError,
    { data: PasswordChange },
    TContext
  >;
  request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authPasswordChangeCreate>>,
  TError,
  { data: PasswordChange },
  TContext
> => {
  const mutationKey = ["authPasswordChangeCreate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authPasswordChangeCreate>>,
    { data: PasswordChange }
  > = (props) => {
    const { data } = props ?? {};

    return authPasswordChangeCreate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthPasswordChangeCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof authPasswordChangeCreate>>
>;
export type AuthPasswordChangeCreateMutationBody = PasswordChange;
export type AuthPasswordChangeCreateMutationError = unknown;

export const useAuthPasswordChangeCreate = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authPasswordChangeCreate>>,
      TError,
      { data: PasswordChange },
      TContext
    >;
    request?: SecondParameter<typeof axiosInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof authPasswordChangeCreate>>,
  TError,
  { data: PasswordChange },
  TContext
> => {
  return useMutation(
    getAuthPasswordChangeCreateMutationOptions(options),
    queryClient,
  );
};
/**
 * Calls Django Auth PasswordResetForm save method.

Accepts the following POST parameters: email
Returns the success/fail message.
 */
export type authPasswordResetCreateResponse200 = {
  data: RestAuthDetail;
  status: 200;
};

export type authPasswordResetCreateResponseSuccess =
  authPasswordResetCreateResponse200 & {
    headers: Headers;
  };
export type authPasswordResetCreateResponse =
  authPasswordResetCreateResponseSuccess;

export const getAuthPasswordResetCreateUrl = () => {
  return `/api/auth/password/reset/`;
};

export const authPasswordResetCreate = async (
  passwordReset: PasswordReset,
  options?: RequestInit,
): Promise<authPasswordResetCreateResponse> => {
  return axiosInstance<authPasswordResetCreateResponse>(
    getAuthPasswordResetCreateUrl(),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(passwordReset),
    },
  );
};

export const getAuthPasswordResetCreateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authPasswordResetCreate>>,
    TError,
    { data: PasswordReset },
    TContext
  >;
  request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authPasswordResetCreate>>,
  TError,
  { data: PasswordReset },
  TContext
> => {
  const mutationKey = ["authPasswordResetCreate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authPasswordResetCreate>>,
    { data: PasswordReset }
  > = (props) => {
    const { data } = props ?? {};

    return authPasswordResetCreate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthPasswordResetCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof authPasswordResetCreate>>
>;
export type AuthPasswordResetCreateMutationBody = PasswordReset;
export type AuthPasswordResetCreateMutationError = unknown;

export const useAuthPasswordResetCreate = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authPasswordResetCreate>>,
      TError,
      { data: PasswordReset },
      TContext
    >;
    request?: SecondParameter<typeof axiosInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof authPasswordResetCreate>>,
  TError,
  { data: PasswordReset },
  TContext
> => {
  return useMutation(
    getAuthPasswordResetCreateMutationOptions(options),
    queryClient,
  );
};
/**
 * Password reset e-mail link is confirmed, therefore
this resets the user's password.

Accepts the following POST parameters: token, uid,
    new_password1, new_password2
Returns the success/fail message.
 */
export type authPasswordResetConfirmCreateResponse200 = {
  data: RestAuthDetail;
  status: 200;
};

export type authPasswordResetConfirmCreateResponseSuccess =
  authPasswordResetConfirmCreateResponse200 & {
    headers: Headers;
  };
export type authPasswordResetConfirmCreateResponse =
  authPasswordResetConfirmCreateResponseSuccess;

export const getAuthPasswordResetConfirmCreateUrl = () => {
  return `/api/auth/password/reset/confirm/`;
};

export const authPasswordResetConfirmCreate = async (
  passwordResetConfirm: PasswordResetConfirm,
  options?: RequestInit,
): Promise<authPasswordResetConfirmCreateResponse> => {
  return axiosInstance<authPasswordResetConfirmCreateResponse>(
    getAuthPasswordResetConfirmCreateUrl(),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(passwordResetConfirm),
    },
  );
};

export const getAuthPasswordResetConfirmCreateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authPasswordResetConfirmCreate>>,
    TError,
    { data: PasswordResetConfirm },
    TContext
  >;
  request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authPasswordResetConfirmCreate>>,
  TError,
  { data: PasswordResetConfirm },
  TContext
> => {
  const mutationKey = ["authPasswordResetConfirmCreate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authPasswordResetConfirmCreate>>,
    { data: PasswordResetConfirm }
  > = (props) => {
    const { data } = props ?? {};

    return authPasswordResetConfirmCreate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthPasswordResetConfirmCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof authPasswordResetConfirmCreate>>
>;
export type AuthPasswordResetConfirmCreateMutationBody = PasswordResetConfirm;
export type AuthPasswordResetConfirmCreateMutationError = unknown;

export const useAuthPasswordResetConfirmCreate = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authPasswordResetConfirmCreate>>,
      TError,
      { data: PasswordResetConfirm },
      TContext
    >;
    request?: SecondParameter<typeof axiosInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof authPasswordResetConfirmCreate>>,
  TError,
  { data: PasswordResetConfirm },
  TContext
> => {
  return useMutation(
    getAuthPasswordResetConfirmCreateMutationOptions(options),
    queryClient,
  );
};
/**
 * Registers a new user.

Accepts the following POST parameters: username, email, password1, password2.
 */
export type authRegistrationCreateResponse201 = {
  data: RestAuthDetail;
  status: 201;
};

export type authRegistrationCreateResponseSuccess =
  authRegistrationCreateResponse201 & {
    headers: Headers;
  };
export type authRegistrationCreateResponse =
  authRegistrationCreateResponseSuccess;

export const getAuthRegistrationCreateUrl = () => {
  return `/api/auth/registration/`;
};

export const authRegistrationCreate = async (
  register: Register,
  options?: RequestInit,
): Promise<authRegistrationCreateResponse> => {
  return axiosInstance<authRegistrationCreateResponse>(
    getAuthRegistrationCreateUrl(),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(register),
    },
  );
};

export const getAuthRegistrationCreateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authRegistrationCreate>>,
    TError,
    { data: Register },
    TContext
  >;
  request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authRegistrationCreate>>,
  TError,
  { data: Register },
  TContext
> => {
  const mutationKey = ["authRegistrationCreate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authRegistrationCreate>>,
    { data: Register }
  > = (props) => {
    const { data } = props ?? {};

    return authRegistrationCreate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthRegistrationCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof authRegistrationCreate>>
>;
export type AuthRegistrationCreateMutationBody = Register;
export type AuthRegistrationCreateMutationError = unknown;

export const useAuthRegistrationCreate = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authRegistrationCreate>>,
      TError,
      { data: Register },
      TContext
    >;
    request?: SecondParameter<typeof axiosInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof authRegistrationCreate>>,
  TError,
  { data: Register },
  TContext
> => {
  return useMutation(
    getAuthRegistrationCreateMutationOptions(options),
    queryClient,
  );
};
/**
 * Resends another email to an unverified email.

Accepts the following POST parameter: email.
 */
export type authRegistrationResendEmailCreateResponse201 = {
  data: RestAuthDetail;
  status: 201;
};

export type authRegistrationResendEmailCreateResponseSuccess =
  authRegistrationResendEmailCreateResponse201 & {
    headers: Headers;
  };
export type authRegistrationResendEmailCreateResponse =
  authRegistrationResendEmailCreateResponseSuccess;

export const getAuthRegistrationResendEmailCreateUrl = () => {
  return `/api/auth/registration/resend-email/`;
};

export const authRegistrationResendEmailCreate = async (
  resendEmailVerification: ResendEmailVerification,
  options?: RequestInit,
): Promise<authRegistrationResendEmailCreateResponse> => {
  return axiosInstance<authRegistrationResendEmailCreateResponse>(
    getAuthRegistrationResendEmailCreateUrl(),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(resendEmailVerification),
    },
  );
};

export const getAuthRegistrationResendEmailCreateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authRegistrationResendEmailCreate>>,
    TError,
    { data: ResendEmailVerification },
    TContext
  >;
  request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authRegistrationResendEmailCreate>>,
  TError,
  { data: ResendEmailVerification },
  TContext
> => {
  const mutationKey = ["authRegistrationResendEmailCreate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authRegistrationResendEmailCreate>>,
    { data: ResendEmailVerification }
  > = (props) => {
    const { data } = props ?? {};

    return authRegistrationResendEmailCreate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthRegistrationResendEmailCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof authRegistrationResendEmailCreate>>
>;
export type AuthRegistrationResendEmailCreateMutationBody =
  ResendEmailVerification;
export type AuthRegistrationResendEmailCreateMutationError = unknown;

export const useAuthRegistrationResendEmailCreate = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authRegistrationResendEmailCreate>>,
      TError,
      { data: ResendEmailVerification },
      TContext
    >;
    request?: SecondParameter<typeof axiosInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof authRegistrationResendEmailCreate>>,
  TError,
  { data: ResendEmailVerification },
  TContext
> => {
  return useMutation(
    getAuthRegistrationResendEmailCreateMutationOptions(options),
    queryClient,
  );
};
/**
 * Verifies the email associated with the provided key.

Accepts the following POST parameter: key.
 */
export type authRegistrationVerifyEmailCreateResponse200 = {
  data: RestAuthDetail;
  status: 200;
};

export type authRegistrationVerifyEmailCreateResponseSuccess =
  authRegistrationVerifyEmailCreateResponse200 & {
    headers: Headers;
  };
export type authRegistrationVerifyEmailCreateResponse =
  authRegistrationVerifyEmailCreateResponseSuccess;

export const getAuthRegistrationVerifyEmailCreateUrl = () => {
  return `/api/auth/registration/verify-email/`;
};

export const authRegistrationVerifyEmailCreate = async (
  verifyEmail: VerifyEmail,
  options?: RequestInit,
): Promise<authRegistrationVerifyEmailCreateResponse> => {
  return axiosInstance<authRegistrationVerifyEmailCreateResponse>(
    getAuthRegistrationVerifyEmailCreateUrl(),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(verifyEmail),
    },
  );
};

export const getAuthRegistrationVerifyEmailCreateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authRegistrationVerifyEmailCreate>>,
    TError,
    { data: VerifyEmail },
    TContext
  >;
  request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authRegistrationVerifyEmailCreate>>,
  TError,
  { data: VerifyEmail },
  TContext
> => {
  const mutationKey = ["authRegistrationVerifyEmailCreate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authRegistrationVerifyEmailCreate>>,
    { data: VerifyEmail }
  > = (props) => {
    const { data } = props ?? {};

    return authRegistrationVerifyEmailCreate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthRegistrationVerifyEmailCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof authRegistrationVerifyEmailCreate>>
>;
export type AuthRegistrationVerifyEmailCreateMutationBody = VerifyEmail;
export type AuthRegistrationVerifyEmailCreateMutationError = unknown;

export const useAuthRegistrationVerifyEmailCreate = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authRegistrationVerifyEmailCreate>>,
      TError,
      { data: VerifyEmail },
      TContext
    >;
    request?: SecondParameter<typeof axiosInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof authRegistrationVerifyEmailCreate>>,
  TError,
  { data: VerifyEmail },
  TContext
> => {
  return useMutation(
    getAuthRegistrationVerifyEmailCreateMutationOptions(options),
    queryClient,
  );
};
/**
 * Reads and updates UserModel fields
Accepts GET, PUT, PATCH methods.

Default accepted fields: username, first_name, last_name
Default display fields: pk, username, email, first_name, last_name
Read-only fields: pk, email

Returns UserModel fields.
 */
export type authUserRetrieveResponse200 = {
  data: UserDetails;
  status: 200;
};

export type authUserRetrieveResponseSuccess = authUserRetrieveResponse200 & {
  headers: Headers;
};
export type authUserRetrieveResponse = authUserRetrieveResponseSuccess;

export const getAuthUserRetrieveUrl = () => {
  return `/api/auth/user/`;
};

export const authUserRetrieve = async (
  options?: RequestInit,
): Promise<authUserRetrieveResponse> => {
  return axiosInstance<authUserRetrieveResponse>(getAuthUserRetrieveUrl(), {
    ...options,
    method: "GET",
  });
};

export const getAuthUserRetrieveQueryKey = () => {
  return [`/api/auth/user/`] as const;
};

export const getAuthUserRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof authUserRetrieve>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof authUserRetrieve>>, TError, TData>
  >;
  request?: SecondParameter<typeof axiosInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthUserRetrieveQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof authUserRetrieve>>
  > = ({ signal }) => authUserRetrieve({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof authUserRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthUserRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof authUserRetrieve>>
>;
export type AuthUserRetrieveQueryError = unknown;

export function useAuthUserRetrieve<
  TData = Awaited<ReturnType<typeof authUserRetrieve>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof authUserRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authUserRetrieve>>,
          TError,
          Awaited<ReturnType<typeof authUserRetrieve>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof axiosInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthUserRetrieve<
  TData = Awaited<ReturnType<typeof authUserRetrieve>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof authUserRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authUserRetrieve>>,
          TError,
          Awaited<ReturnType<typeof authUserRetrieve>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof axiosInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthUserRetrieve<
  TData = Awaited<ReturnType<typeof authUserRetrieve>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof authUserRetrieve>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof axiosInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useAuthUserRetrieve<
  TData = Awaited<ReturnType<typeof authUserRetrieve>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof authUserRetrieve>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof axiosInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAuthUserRetrieveQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Reads and updates UserModel fields
Accepts GET, PUT, PATCH methods.

Default accepted fields: username, first_name, last_name
Default display fields: pk, username, email, first_name, last_name
Read-only fields: pk, email

Returns UserModel fields.
 */
export type authUserUpdateResponse200 = {
  data: UserDetails;
  status: 200;
};

export type authUserUpdateResponseSuccess = authUserUpdateResponse200 & {
  headers: Headers;
};
export type authUserUpdateResponse = authUserUpdateResponseSuccess;

export const getAuthUserUpdateUrl = () => {
  return `/api/auth/user/`;
};

export const authUserUpdate = async (
  userDetails: NonReadonly<UserDetails>,
  options?: RequestInit,
): Promise<authUserUpdateResponse> => {
  return axiosInstance<authUserUpdateResponse>(getAuthUserUpdateUrl(), {
    ...options,
    method: "PUT",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(userDetails),
  });
};

export const getAuthUserUpdateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authUserUpdate>>,
    TError,
    { data: NonReadonly<UserDetails> },
    TContext
  >;
  request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authUserUpdate>>,
  TError,
  { data: NonReadonly<UserDetails> },
  TContext
> => {
  const mutationKey = ["authUserUpdate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authUserUpdate>>,
    { data: NonReadonly<UserDetails> }
  > = (props) => {
    const { data } = props ?? {};

    return authUserUpdate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthUserUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof authUserUpdate>>
>;
export type AuthUserUpdateMutationBody = NonReadonly<UserDetails>;
export type AuthUserUpdateMutationError = unknown;

export const useAuthUserUpdate = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authUserUpdate>>,
      TError,
      { data: NonReadonly<UserDetails> },
      TContext
    >;
    request?: SecondParameter<typeof axiosInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof authUserUpdate>>,
  TError,
  { data: NonReadonly<UserDetails> },
  TContext
> => {
  return useMutation(getAuthUserUpdateMutationOptions(options), queryClient);
};
/**
 * Reads and updates UserModel fields
Accepts GET, PUT, PATCH methods.

Default accepted fields: username, first_name, last_name
Default display fields: pk, username, email, first_name, last_name
Read-only fields: pk, email

Returns UserModel fields.
 */
export type authUserPartialUpdateResponse200 = {
  data: UserDetails;
  status: 200;
};

export type authUserPartialUpdateResponseSuccess =
  authUserPartialUpdateResponse200 & {
    headers: Headers;
  };
export type authUserPartialUpdateResponse =
  authUserPartialUpdateResponseSuccess;

export const getAuthUserPartialUpdateUrl = () => {
  return `/api/auth/user/`;
};

export const authUserPartialUpdate = async (
  patchedUserDetails: NonReadonly<PatchedUserDetails>,
  options?: RequestInit,
): Promise<authUserPartialUpdateResponse> => {
  return axiosInstance<authUserPartialUpdateResponse>(
    getAuthUserPartialUpdateUrl(),
    {
      ...options,
      method: "PATCH",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(patchedUserDetails),
    },
  );
};

export const getAuthUserPartialUpdateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authUserPartialUpdate>>,
    TError,
    { data: NonReadonly<PatchedUserDetails> },
    TContext
  >;
  request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authUserPartialUpdate>>,
  TError,
  { data: NonReadonly<PatchedUserDetails> },
  TContext
> => {
  const mutationKey = ["authUserPartialUpdate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authUserPartialUpdate>>,
    { data: NonReadonly<PatchedUserDetails> }
  > = (props) => {
    const { data } = props ?? {};

    return authUserPartialUpdate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthUserPartialUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof authUserPartialUpdate>>
>;
export type AuthUserPartialUpdateMutationBody = NonReadonly<PatchedUserDetails>;
export type AuthUserPartialUpdateMutationError = unknown;

export const useAuthUserPartialUpdate = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authUserPartialUpdate>>,
      TError,
      { data: NonReadonly<PatchedUserDetails> },
      TContext
    >;
    request?: SecondParameter<typeof axiosInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof authUserPartialUpdate>>,
  TError,
  { data: NonReadonly<PatchedUserDetails> },
  TContext
> => {
  return useMutation(
    getAuthUserPartialUpdateMutationOptions(options),
    queryClient,
  );
};
